"""
PROOF: PHP-C Formal Selector Identity Verification
====================================================

We verify whether the explicit selectors for PHP-C satisfy
the FORMAL polynomial identity:

    Sum_p g_p = 1 (mod I)

where I is the ideal generated by the PHP-C axioms.

This means: Sum_p g_p - 1 = Sum_i h_i * f_i
for some multiplier polynomials h_i.

This is an IPS feasibility problem. We set it up as a
linear system and solve with LSQR.

Author: Carmen Esteban
Date: February 2026
"""

import numpy as np
from scipy import sparse
from scipy.sparse.linalg import lsqr
from itertools import combinations, permutations
from math import comb
import time


def build_phpc_axioms(n):
    """Build PHP-C axiom system."""
    pigeons = list(range(1, n + 2))
    holes = list(range(1, n + 1))

    var_x = {}
    var_s = {}
    idx = 0
    for p in pigeons:
        for h in holes:
            var_x[(p, h)] = idx
            idx += 1
    for p in pigeons:
        for q in pigeons:
            if p != q:
                var_s[(p, q)] = idx
                idx += 1
    num_vars = idx
    axioms = []
    axiom_names = []

    # Existence
    for p in pigeons:
        terms = []
        hvars = [var_x[(p, h)] for h in holes]
        for k in range(len(hvars) + 1):
            sign = (-1.0) ** k
            for subset in combinations(hvars, k):
                terms.append((sign, frozenset(subset)))
        axioms.append(terms)
        axiom_names.append("exist_p{}".format(p))

    # Hole exclusion
    for h in holes:
        for i, p in enumerate(pigeons):
            for p2 in pigeons[i + 1:]:
                axioms.append([(1.0, frozenset([var_x[(p, h)],
                                                var_x[(p2, h)]]))])
                axiom_names.append("hole_{}_{}_{}".format(h, p, p2))

    # Pigeon exclusion
    for p in pigeons:
        for j, h in enumerate(holes):
            for h2 in holes[j + 1:]:
                axioms.append([(1.0, frozenset([var_x[(p, h)],
                                                var_x[(p, h2)]]))])
                axiom_names.append("pig_{}_{}{}".format(p, h, h2))

    # Successor existence
    for p in pigeons:
        terms = []
        svars = [var_s[(p, q)] for q in pigeons if q != p]
        for k in range(len(svars) + 1):
            sign = (-1.0) ** k
            for subset in combinations(svars, k):
                terms.append((sign, frozenset(subset)))
        axioms.append(terms)
        axiom_names.append("succ_exist_{}".format(p))

    # Successor exclusion (at most one successor)
    for p in pigeons:
        others = [q for q in pigeons if q != p]
        for i, q in enumerate(others):
            for q2 in others[i + 1:]:
                axioms.append([(1.0, frozenset([var_s[(p, q)],
                                                var_s[(p, q2)]]))])
                axiom_names.append("succ_excl_{}_{}{}".format(p, q, q2))

    # Predecessor existence
    for q in pigeons:
        terms = []
        svars = [var_s[(p, q)] for p in pigeons if p != q]
        for k in range(len(svars) + 1):
            sign = (-1.0) ** k
            for subset in combinations(svars, k):
                terms.append((sign, frozenset(subset)))
        axioms.append(terms)
        axiom_names.append("pred_exist_{}".format(q))

    # Predecessor exclusion
    for q in pigeons:
        others = [p for p in pigeons if p != q]
        for i, p in enumerate(others):
            for p2 in others[i + 1:]:
                axioms.append([(1.0, frozenset([var_s[(p, q)],
                                                var_s[(p2, q)]]))])
                axiom_names.append("pred_excl_{}_{}{}".format(q, p, p2))

    # Circular consistency
    def succ_hole(h):
        return (h % n) + 1
    for p in pigeons:
        for q in pigeons:
            if p == q:
                continue
            s_idx = var_s[(p, q)]
            for h in holes:
                for h2 in holes:
                    if h2 == succ_hole(h):
                        continue
                    axioms.append([(1.0, frozenset([s_idx,
                                                    var_x[(p, h)],
                                                    var_x[(q, h2)]]))])
                    axiom_names.append("circ_{}{}_{}_{}".format(
                        p, q, h, h2))

    return axioms, num_vars, var_x, var_s, axiom_names


def build_ips_matrix(axioms, num_vars, d_max):
    """Build IPS matrix: A @ coeffs = b means Sum h_i * f_i = target."""
    all_monoms = []
    monom_to_idx = {}
    for d in range(d_max + 1):
        for combo in combinations(range(num_vars), d):
            m = frozenset(combo)
            monom_to_idx[m] = len(all_monoms)
            all_monoms.append(m)
    num_monoms = len(all_monoms)

    rows, cols, vals = [], [], []
    total_unknowns = 0
    for ax in axioms:
        deg_ax = max(len(m) for c, m in ax)
        deg_mult = max(0, d_max - deg_ax)
        for d in range(deg_mult + 1):
            for combo in combinations(range(num_vars), d):
                m_mult = frozenset(combo)
                col = total_unknowns
                total_unknowns += 1
                for coef_ax, m_ax in ax:
                    m_prod = m_mult | m_ax
                    if len(m_prod) <= d_max and m_prod in monom_to_idx:
                        rows.append(monom_to_idx[m_prod])
                        cols.append(col)
                        vals.append(coef_ax)

    if total_unknowns == 0:
        return None, None, num_monoms, 0, monom_to_idx

    A = sparse.csr_matrix((vals, (rows, cols)),
                          shape=(num_monoms, total_unknowns))
    b = np.zeros(num_monoms)
    return A, b, num_monoms, total_unknowns, monom_to_idx


def build_selector_polynomial(n, target_pigeon, var_x, var_s):
    """Build explicit selector g_p using path formula.

    g_p = Sum_{p0 != p} x_{p0, 1} * indicator_n(p0, p, s)
    """
    pigeons = list(range(1, n + 2))
    terms = []
    for p0 in pigeons:
        if p0 == target_pigeon:
            continue
        intermediates = [q for q in pigeons
                          if q != p0 and q != target_pigeon]
        for path_mid in permutations(intermediates):
            path = [p0] + list(path_mid) + [target_pigeon]
            monom = frozenset([var_x[(p0, 1)]])
            for i in range(len(path) - 1):
                monom = monom | frozenset([var_s[(path[i], path[i+1])]])
            terms.append((1.0, monom))
    return terms


def sum_selectors_polynomial(n, var_x, var_s):
    """Compute Sum_p g_p as a polynomial."""
    pigeons = list(range(1, n + 2))
    all_terms = []
    for p in pigeons:
        terms = build_selector_polynomial(n, p, var_x, var_s)
        all_terms.extend(terms)

    # Combine like terms
    combined = {}
    for c, m in all_terms:
        combined[m] = combined.get(m, 0) + c
    result = [(c, m) for m, c in combined.items() if abs(c) > 1e-15]
    return result


def check_formal_identity(n, max_degree):
    """Check if Sum g_p - 1 is in the ideal I.

    This means: can we write Sum g_p - 1 = Sum h_i * f_i ?
    Equivalent to: is the polynomial (Sum g_p - 1) in the
    column span of the IPS matrix?
    """
    print("\nBuilding PHP-C({}) axiom system...".format(n))
    axioms, num_vars, var_x, var_s, ax_names = build_phpc_axioms(n)
    print("  Variables: {}, Axioms: {}".format(num_vars, len(axioms)))

    # Compute Sum g_p - 1
    print("Computing Sum g_p - 1...")
    sum_gp = sum_selectors_polynomial(n, var_x, var_s)
    print("  Sum g_p has {} terms".format(len(sum_gp)))

    # Compute the degree of Sum g_p
    max_gp_deg = max(len(m) for _, m in sum_gp) if sum_gp else 0
    print("  Max degree of Sum g_p: {}".format(max_gp_deg))

    for d in range(max(2, max_gp_deg), max_degree + 1):
        nm_est = sum(comb(num_vars, k) for k in range(d + 1))
        if nm_est > 500000:
            print("  d={}: ~{} monomials (too large)".format(d, nm_est))
            break

        print("\n  Checking degree {}...".format(d))
        t0 = time.time()
        A, _, nm, nu, monom_to_idx = build_ips_matrix(axioms, num_vars, d)
        t_build = time.time() - t0

        if A is None:
            print("    No unknowns at this degree")
            continue

        # Build target: Sum g_p - 1
        b = np.zeros(nm)
        # Subtract 1 (constant term)
        b[monom_to_idx[frozenset()]] = -1.0
        # Add Sum g_p terms
        for coef, monom in sum_gp:
            if monom in monom_to_idx:
                b[monom_to_idx[monom]] += coef
            else:
                print("    WARNING: monomial {} not in basis at degree {}".format(
                    monom, d))

        # Solve: A @ h = b (find multipliers h)
        t0 = time.time()
        res = lsqr(A, b, atol=1e-12, btol=1e-12, iter_lim=10000)
        h = res[0]
        residual = np.linalg.norm(A @ h - b)
        t_solve = time.time() - t0

        feasible = residual < 1e-6
        print("    Matrix: {}x{}, residual: {:.2e} [{:.1f}s]".format(
            nm, nu, residual, t_build + t_solve))

        if feasible:
            nonzero = int(np.sum(np.abs(h) > 1e-8))
            print("    FEASIBLE! Sum g_p - 1 IN ideal at degree {}".format(d))
            print("    Multiplier nonzeros: {}".format(nonzero))
            return True, d, nonzero
        else:
            print("    INFEASIBLE at degree {}".format(d))

    return False, None, None


def check_standard_certificate(n, max_degree):
    """For comparison: find the standard IPS certificate (no selectors)."""
    print("\nStandard IPS certificate for PHP-C({})...".format(n))
    axioms, num_vars, _, _, _ = build_phpc_axioms(n)

    for d in range(2, max_degree + 1):
        nm_est = sum(comb(num_vars, k) for k in range(d + 1))
        if nm_est > 500000:
            break

        A, _, nm, nu, monom_to_idx = build_ips_matrix(axioms, num_vars, d)
        if A is None:
            continue

        b = np.zeros(nm)
        b[monom_to_idx[frozenset()]] = 1.0

        res = lsqr(A, b, atol=1e-12, btol=1e-12, iter_lim=10000)
        x = res[0]
        residual = np.linalg.norm(A @ x - b)
        feasible = residual < 1e-6

        if feasible:
            size = int(np.sum(np.abs(x) > 1e-8))
            print("  d={}: FEASIBLE, SIZE_L2={}".format(d, size))
            return d, size

        print("  d={}: infeasible (res={:.2e})".format(d, residual))

    return None, None


if __name__ == "__main__":
    print("=" * 60)
    print("FORMAL IDENTITY: Sum g_p = 1 (mod I) for PHP-C")
    print("=" * 60)

    for n in [2, 3]:
        print("\n" + "=" * 60)
        print("n = {} ({} pigeons, {} holes)".format(n, n + 1, n))
        print("=" * 60)

        # Standard certificate (reference)
        d_std, size_std = check_standard_certificate(n, max_degree=8)

        # Formal identity check
        ok, d_id, size_id = check_formal_identity(n, max_degree=8)

        print("\n--- Summary for n={} ---".format(n))
        if d_std:
            print("  Standard certificate: degree {}, SIZE_L2={}".format(
                d_std, size_std))
        if ok:
            print("  Selector identity Sum g_p = 1 (mod I): "
                  "VERIFIED at degree {}, {} multiplier nonzeros".format(
                      d_id, size_id))
        else:
            print("  Selector identity: NOT verified up to tested degree")
            print("  => Explicit selectors may not satisfy formal identity")
            print("  => Need different selector construction or higher degree")

    print("\n" + "=" * 60)
    print("ANALYSIS")
    print("=" * 60)
    print("""
The formal identity Sum g_p = 1 (mod I) requires that the
polynomial (Sum g_p - 1) can be written as a linear combination
of the PHP-C axioms with polynomial multipliers.

If VERIFIED: the explicit selectors work formally, and we can
decompose the IPS certificate as C = Sum g_p * C_p.
The selector cost is (n+1)! terms (factorial).

If NOT VERIFIED: the path-formula selectors don't satisfy the
formal identity, and we need a different construction.
Either way, PHP-C is NOT Level 1 (s-only selectors are
infeasible, proven in 05_phpc_selector_lower_bound.py).
""")
    print("=" * 60)
